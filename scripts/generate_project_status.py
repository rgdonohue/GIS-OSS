#!/usr/bin/env python3
"""
Generate an implementation status document from current repository contents.

This script intentionally reads from code and tests instead of hand-maintained
roadmap notes, so project status can be validated in CI.
"""

from __future__ import annotations

import argparse
import pathlib
import re
import sys

ROOT = pathlib.Path(__file__).resolve().parents[1]
TARGET_DOC = ROOT / "docs" / "project_status.md"


def _read_text(path: pathlib.Path) -> str:
    return path.read_text(encoding="utf-8")


def _find_api_endpoints(api_text: str) -> list[tuple[str, str]]:
    pattern = re.compile(r'@app\.(get|post|put|delete|patch)\("([^"]+)"')
    return [(method.upper(), route) for method, route in pattern.findall(api_text)]


def _find_structured_operations(api_text: str) -> list[str]:
    pattern = re.compile(r'if op == "([^"]+)"')
    return pattern.findall(api_text)


def _count_tests() -> tuple[int, int]:
    test_files = sorted((ROOT / "tests").rglob("test_*.py"))
    test_case_count = 0
    for test_file in test_files:
        text = _read_text(test_file)
        test_case_count += len(re.findall(r"^def test_", text, flags=re.MULTILINE))
    return len(test_files), test_case_count


def _build_status_markdown() -> str:
    api_text = _read_text(ROOT / "src" / "api" / "main.py")
    auth_text = _read_text(ROOT / "src" / "security" / "authorization.py")
    rate_limit_text = _read_text(ROOT / "src" / "security" / "rate_limit.py")
    config_text = _read_text(ROOT / "src" / "api" / "config.py")

    endpoints = _find_api_endpoints(api_text)
    operations = _find_structured_operations(api_text)
    test_files, test_cases = _count_tests()

    authz_mode = (
        "permissive scaffold (check_permission returns True)"
        if "return True" in auth_text
        else "enforced role/permission map"
    )
    rate_limiter_mode = (
        "in-memory token bucket"
        if "class RateLimiter" in rate_limit_text and "OrderedDict" in rate_limit_text
        else "unknown"
    )
    has_natural_route = '"/query/natural"' in api_text
    has_local_planner = "plan_operation_from_prompt" in api_text and "ENABLE_LOCAL_LLM_PLANNER" in config_text
    if has_natural_route and "parse_natural_query_prompt" in api_text and has_local_planner:
        nl_status = (
            "strict parser on `/query/natural`; optional local LLM planner "
            "for `/query` behind `ENABLE_LOCAL_LLM_PLANNER`"
        )
    elif has_natural_route and "parse_natural_query_prompt" in api_text:
        nl_status = (
            "strict parser implemented on `/query/natural` "
            "(requires embedded operation JSON); `/query` is still pending when "
            "`operation` is absent"
        )
    elif "LLM orchestration not yet implemented." in api_text:
        nl_status = "not implemented (`/query` returns pending when `operation` is absent)"
    else:
        nl_status = "implemented"
    table_allowlist_status = (
        "enabled (`ALLOWED_QUERY_TABLES` in settings)"
        if "ALLOWED_QUERY_TABLES" in config_text
        else "not detected"
    )
    authz_backend_status = (
        "database-first with static fallback (`AUTHZ_BACKEND`)"
        if "AUTHZ_BACKEND" in config_text and "resolve_role(" in api_text
        else "static-only"
    )
    audit_log_status = (
        "enabled (redacted DB audit writes on `/query`)"
        if "enable_audit_log" in config_text and "log_query_event(" in api_text
        else "not detected"
    )
    grounding_contract_status = (
        "enabled (`verification_status` + `evidence` included on query responses)"
        if "verification_status" in api_text and "evidence" in api_text
        else "not detected"
    )
    telemetry_status = (
        "trace correlation enabled in audit metadata (optional OTel)"
        if "otel_enabled" in config_text and "current_trace_id()" in api_text
        else "not detected"
    )

    endpoint_lines = "\n".join(f"- `{method} {route}`" for method, route in endpoints)
    operation_lines = "\n".join(f"- `{operation}`" for operation in operations)

    return f"""# Project Status (Generated)

Source of truth for current implementation status. Generated from repository code and test files.

- Generated by: `scripts/generate_project_status.py`

## API Surface (Observed)
{endpoint_lines}

## Structured Spatial Operations (Observed)
{operation_lines}

## Current Behavior Flags (Observed)
- NL orchestration: {nl_status}
- Authorization mode: {authz_mode}
- Authorization backend: {authz_backend_status}
- Rate limiting mode: {rate_limiter_mode}
- Query table allowlist: {table_allowlist_status}
- Audit logging: {audit_log_status}
- Response grounding contract: {grounding_contract_status}
- Telemetry: {telemetry_status}

## Test Inventory (Static)
- Test files: `{test_files}`
- Test cases (`def test_*`): `{test_cases}`

## Notes
- This document is generated. Do not hand-edit.
- CI validates this file stays in sync with code (`python scripts/generate_project_status.py --check`).
"""


def _check_or_write(check: bool) -> int:
    rendered = _build_status_markdown()

    if check:
        if not TARGET_DOC.exists():
            print(f"Missing generated file: {TARGET_DOC}")
            return 1
        existing = _read_text(TARGET_DOC)
        if existing != rendered:
            print("Generated status document is out of date.")
            print("Run: python scripts/generate_project_status.py")
            return 1
        print("Generated status document is up to date.")
        return 0

    TARGET_DOC.parent.mkdir(parents=True, exist_ok=True)
    TARGET_DOC.write_text(rendered, encoding="utf-8")
    print(f"Wrote {TARGET_DOC.relative_to(ROOT)}")
    return 0


def main() -> int:
    parser = argparse.ArgumentParser(description="Generate code-derived project status doc.")
    parser.add_argument(
        "--check",
        action="store_true",
        help="Fail if docs/project_status.md is not up to date.",
    )
    args = parser.parse_args()
    return _check_or_write(check=args.check)


if __name__ == "__main__":
    sys.exit(main())
